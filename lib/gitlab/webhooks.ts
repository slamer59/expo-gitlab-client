import { webhookName, webhooksUrl } from "../firebase/constants";
import { GitLabSession } from "../session/SessionProvider";

type WebhookParams = {
    name?: string;
    description?: string;
    url: string;
    push_events?: boolean;
    push_events_branch_filter?: string;
    issues_events?: boolean;
    confidential_issues_events?: boolean;
    merge_requests_events?: boolean;
    // Add other properties as needed
    custom_webhook_template?: string;
    [key: string]: any; // Add this index signature
};

export async function updateOrCreateWebhook(session: GitLabSession, projectId: number, projectName: string, webhookParams: WebhookParams | undefined): Promise<any> {
    // Get the private token from secure storage
    const { token: savedToken, url: baseUrl } = session;

    let paramsWebhook: WebhookParams = {
        name: webhookName,
        description: "Webhook for GitLab events generated by gitalchemy",
        url: webhooksUrl,
        push_events: true,
        // push_events_branch_filter: "",
        issues_events: true,
        confidential_issues_events: true,
        merge_requests_events: true,
        tag_push_events: true,
        note_events: true,
        confidential_note_events: true,
        job_events: true,
        pipeline_events: true,
        wiki_page_events: true,
        deployment_events: true,
        releases_events: true,
        enable_ssl_verification: true,
        repository_update_events: true,
        alert_status: "executable",
        disabled_until: null,
        // url_variables: [],
        // created_at: "2012-10-12T17:04:47Z",
        resource_access_token_events: true,
        feature_flags_events: true,
        emoji_events: true,
        // custom_webhook_template: '{"event":"{{object_kind}}"}',
        // # "custom_headers": [{ "key": "Authorization" }],
        // # "push_events_branch_filter": "main",
        // # "token": "secret-token",
    }

    // replace param in paramsWebhook with webhookParams    
    if (webhookParams) {
        Object.keys(webhookParams).forEach(key => {
            if (webhookParams[key] !== undefined) {
                paramsWebhook[key] = webhookParams[key];
            }
        });
    }

    if (savedToken) {
        // Set the headers for the API request
        const headers = {
            'PRIVATE-TOKEN': savedToken,
            'Content-Type': 'application/x-www-form-urlencoded',
        };
        // Get all webhooks for the project
        const response = await fetch(`${baseUrl}/api/v4/projects/${projectId}/hooks`, {
            headers,
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const webhooks = await response.json();
        // Check if a webhook with the same URL already exists
        const existingWebhook = webhooks.find((webhook: { name: string; }) => webhook.name === webhookName);
        if (existingWebhook) {
            // Update the existing webhook
            const updateResponse = await fetch(`${baseUrl}/api/v4/projects/${projectId}/hooks/${existingWebhook.id}`, {
                method: 'PUT',
                headers: {
                    'PRIVATE-TOKEN': savedToken,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(paramsWebhook),
            });

            if (!updateResponse.ok) {
                throw new Error(`HTTP error! status: ${updateResponse.status}`);
            }

            const updatedWebhook = await updateResponse.json();
            return updatedWebhook;
        } else {
            console.log("No existing webhook found for project id: ", projectId);
            // Create a new webhook
            const createResponse = await fetch(`${baseUrl}/api/v4/projects/${projectId}/hooks`, {
                method: 'POST',
                headers: {
                    'PRIVATE-TOKEN': savedToken,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(paramsWebhook),
            });
            if (!createResponse.ok) {
                throw new Error(`HTTP error! status: ${createResponse.status}`);
            }
            const newWebhook = await createResponse.json();
            return newWebhook;
        }
    } else {
        console.log("No token found");

    }
}

const removeWebhook = async (session: GitLabSession, projectId: number, projectName: string): Promise<void> => {
    // Get the private token from secure storage
    const { token: savedToken, url: baseUrl } = session;
    if (savedToken) {
        // Set the headers for the API request
        const headers = {
            'PRIVATE-TOKEN': savedToken,
            'Content-Type': 'application/x-www-form-urlencoded',
        };
        // Get all webhooks for the project
        const response = await fetch(`${baseUrl}/api/v4/projects/${projectId}/hooks`, {
            headers,
        });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const webhooks = await response.json();
        // Check if a webhook with the same URL already exists
        const existingWebhook = webhooks.find((webhook: { name: string; }) => webhook.name === webhookName);
        if (existingWebhook) {
            // Delete the existing webhook
            const deleteResponse = await fetch(`${baseUrl}/api/v4/projects/${projectId}/hooks/${existingWebhook.id}`, {
                method: 'DELETE',
                headers: {
                    'PRIVATE-TOKEN': savedToken,
                    'Content-Type': 'application/json',
                },
            });
            if (!deleteResponse.ok) {
                throw new Error(`HTTP error! status: ${deleteResponse.status}`);
            }
            console.log(`Webhook removed for project: ${projectId}`);
        } else {
            console.log(`No existing webhook found for project: ${projectId}`);
        }
    } else {
        console.log("No token found");
    }
};

export async function updateOrCreateWebhooks(session: GitLabSession, projects: { id: number; name: string }[], webhookParams: WebhookParams | undefined): any {
    // Update or create webhooks for each project
    const webhookPromises = projects.map(project => updateOrCreateWebhook(session, project.id, project.name, webhookParams));
    // Wait for all webhook updates/creations to complete
    return Promise.all(webhookPromises);

}


export async function removeWebhooks(session: GitLabSession, projects: { id: number; name: string }[]): Promise<void> {
    // Remove webhooks for each project
    const webhookPromises = projects.map(project => removeWebhook(session, project.id, project.name));
    // Wait for all webhook removals to complete
    await Promise.all(webhookPromises)
        .then(() => {
            console.log("All webhooks removed successfully");
        })
}